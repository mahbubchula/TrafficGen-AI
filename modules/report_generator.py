"""
Automated Report Generator
Creates professional PDF reports with charts and analysis
"""

import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime
from typing import Dict, List
import base64
from io import BytesIO

class ReportGenerator:
    """Generate comprehensive analysis reports"""
    
    def __init__(self):
        """Initialize report generator"""
        self.report_template = """
# TrafficGen-AI Analysis Report

**Generated:** {timestamp}  
**Researcher:** {researcher}  
**Institution:** {institution}

---

## Executive Summary

{executive_summary}

---

## Policy Overview

{policy_overview}

---

## Climate Scenario Analysis

{climate_analysis}

---

## Performance Metrics

{performance_metrics}

---

## Statistical Analysis

{statistical_analysis}

---

## Multi-Objective Optimization

{optimization_analysis}

---

## Visualizations

{visualizations}

---

## Key Findings

{key_findings}

---

## Recommendations

{recommendations}

---

## Methodology

{methodology}

---

## Appendix

{appendix}

---

*Report generated by TrafficGen-AI*  
*Developed by Mahbub Hassan, Chulalongkorn University*
"""
    
    def generate_markdown_report(self,
                                results: Dict,
                                policies: List[Dict],
                                stats_report: str = "",
                                optimization_report: str = "",
                                researcher: str = "MAHBUB HASSAN",
                                institution: str = "Chulalongkorn University") -> str:
        """
        Generate comprehensive markdown report
        
        Args:
            results: Simulation results
            policies: List of policy configurations
            stats_report: Statistical analysis report
            optimization_report: Optimization report
            researcher: Researcher name
            institution: Institution name
            
        Returns:
            Formatted markdown report
        """
        
        # Executive Summary
        executive_summary = self._generate_executive_summary(results, policies)
        
        # Policy Overview
        policy_overview = self._generate_policy_overview(policies)
        
        # Climate Analysis
        climate_analysis = self._generate_climate_analysis(results)
        
        # Performance Metrics
        performance_metrics = self._generate_performance_metrics(results)
        
        # Key Findings
        key_findings = self._generate_key_findings(results)
        
        # Recommendations
        recommendations = self._generate_recommendations(results)
        
        # Methodology
        methodology = self._generate_methodology()
        
        # Appendix
        appendix = self._generate_appendix(policies)
        
        # Fill template
        report = self.report_template.format(
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            researcher=researcher,
            institution=institution,
            executive_summary=executive_summary,
            policy_overview=policy_overview,
            climate_analysis=climate_analysis,
            performance_metrics=performance_metrics,
            statistical_analysis=stats_report if stats_report else "Not available",
            optimization_analysis=optimization_report if optimization_report else "Not available",
            visualizations="See attached charts and figures",
            key_findings=key_findings,
            recommendations=recommendations,
            methodology=methodology,
            appendix=appendix
        )
        
        return report
    
    def _generate_executive_summary(self, results: Dict, policies: List[Dict]) -> str:
        """Generate executive summary"""
        num_policies = len(policies)
        num_scenarios = len(set(scenario for policy_results in results.values() 
                               for scenario in policy_results.keys()))
        
        summary = f"""
This report presents a comprehensive analysis of {num_policies} traffic management policies 
evaluated under {num_scenarios} climate scenarios using AI-assisted policy generation and 
microsimulation-based evaluation.

**Key Highlights:**
- Total simulations conducted: {num_policies * num_scenarios}
- Evaluation framework: Climate-adaptive traffic policy assessment
- Analysis methods: Multi-objective optimization, statistical testing, sensitivity analysis
- AI Model: Llama 3.3 70B for policy generation and interpretation
"""
        return summary
    
    def _generate_policy_overview(self, policies: List[Dict]) -> str:
        """Generate policy overview section"""
        overview = "### Evaluated Policies\n\n"
        
        for i, policy in enumerate(policies, 1):
            overview += f"**{i}. {policy.get('policy_name', 'Unnamed Policy')}**\n\n"
            overview += f"- **Type:** {policy.get('policy_type', 'N/A')}\n"
            overview += f"- **Objective:** {policy.get('generation_metadata', {}).get('policy_objective', 'N/A')}\n"
            overview += f"- **Description:** {policy.get('description', 'N/A')}\n\n"
        
        return overview
    
    def _generate_climate_analysis(self, results: Dict) -> str:
        """Generate climate scenario analysis"""
        analysis = "### Climate Scenario Performance\n\n"
        
        # Get all unique scenarios
        scenarios = set()
        for policy_results in results.values():
            scenarios.update(policy_results.keys())
        
        analysis += f"Policies were evaluated under {len(scenarios)} climate scenarios:\n\n"
        
        for scenario in sorted(scenarios):
            analysis += f"- **{scenario.replace('_', ' ').title()}**\n"
        
        return analysis
    
    def _generate_performance_metrics(self, results: Dict) -> str:
        """Generate performance metrics summary"""
        metrics_summary = "### Performance Summary Table\n\n"
        
        metrics_summary += "| Policy | Scenario | Avg Delay (s) | Throughput (veh/h) | COâ‚‚ (kg) | Avg Speed (km/h) |\n"
        metrics_summary += "|--------|----------|---------------|-------------------|----------|------------------|\n"
        
        for policy_name, scenarios in results.items():
            for scenario_name, data in scenarios.items():
                metrics = data['metrics']
                metrics_summary += f"| {policy_name[:20]} | {scenario_name} | "
                metrics_summary += f"{metrics.get('average_delay', 0):.1f} | "
                metrics_summary += f"{metrics.get('throughput', 0):.0f} | "
                metrics_summary += f"{metrics.get('co2_emissions', 0):.2f} | "
                metrics_summary += f"{metrics.get('average_speed', 0):.1f} |\n"
        
        return metrics_summary
    
    def _generate_key_findings(self, results: Dict) -> str:
        """Generate key findings"""
        findings = ""
        
        # Find best performers
        best_delay = min(results.items(), 
                        key=lambda x: min(s['metrics'].get('average_delay', float('inf')) 
                                        for s in x[1].values()))
        
        best_emissions = min(results.items(),
                            key=lambda x: min(s['metrics'].get('co2_emissions', float('inf'))
                                            for s in x[1].values()))
        
        findings += f"1. **Best Policy for Delay Reduction:** {best_delay[0]}\n"
        findings += f"2. **Best Policy for Emission Reduction:** {best_emissions[0]}\n"
        findings += f"3. **Total Policies Evaluated:** {len(results)}\n"
        findings += f"4. **Climate Scenarios Tested:** {len(list(results.values())[0])}\n"
        
        return findings
    
    def _generate_recommendations(self, results: Dict) -> str:
        """Generate recommendations"""
        recommendations = """
Based on the comprehensive analysis, the following recommendations are proposed:

1. **Short-term Implementation:**
   - Prioritize policies showing robust performance across multiple climate scenarios
   - Focus on quick-win strategies with minimal infrastructure requirements

2. **Long-term Planning:**
   - Develop adaptive strategies that can be adjusted based on actual climate impacts
   - Invest in monitoring infrastructure to validate simulation predictions

3. **Risk Mitigation:**
   - Maintain policy flexibility to respond to extreme climate events
   - Consider hybrid approaches combining multiple policy types

4. **Future Research:**
   - Expand simulation to larger network scales
   - Incorporate real-world traffic data for validation
   - Investigate long-term sustainability impacts
"""
        return recommendations
    
    def _generate_methodology(self) -> str:
        """Generate methodology section"""
        methodology = """
### Research Framework

This study employs a novel LLM-assisted framework for climate-adaptive traffic policy generation:

**1. Policy Generation:**
- Large Language Model (Llama 3.3 70B) generates structured policy configurations
- Context-aware prompts ensure relevance to climate scenarios
- Automatic validation of policy parameters

**2. Traffic Simulation:**
- SUMO-based microsimulation platform
- Climate stress scenarios modeled through capacity reduction and efficiency loss
- Synthetic traffic demand generation

**3. Performance Evaluation:**
- Multi-dimensional metrics: delay, throughput, emissions, speed
- Statistical significance testing (ANOVA)
- Multi-objective optimization analysis

**4. AI-Powered Interpretation:**
- Natural language insights generation
- Trade-off analysis and policy comparison
- Actionable recommendations synthesis

### Limitations

- Simplified network representations in current implementation
- Synthetic traffic data (future versions will integrate real data)
- Climate scenario parameters based on literature estimates
- Single replication per scenario (future work: Monte Carlo)
"""
        return methodology
    
    def _generate_appendix(self, policies: List[Dict]) -> str:
        """Generate appendix with detailed policy configurations"""
        appendix = "### Policy Configuration Details\n\n"
        
        for i, policy in enumerate(policies, 1):
            appendix += f"#### Policy {i}: {policy.get('policy_name', 'Unnamed')}\n\n"
            
            if 'parameters' in policy:
                appendix += "**Parameters:**\n\n"
                for key, value in policy['parameters'].items():
                    appendix += f"- {key}: {value}\n"
                appendix += "\n"
            
            if 'expected_impacts' in policy:
                appendix += "**Expected Impacts:**\n\n"
                for key, value in policy['expected_impacts'].items():
                    appendix += f"- {key}: {value}\n"
                appendix += "\n"
        
        return appendix
    
    def create_visualization_figure(self, results: Dict, chart_type: str = "bar") -> go.Figure:
        """
        Create visualization figure for report
        
        Args:
            results: Simulation results
            chart_type: Type of chart ('bar', 'line', 'heatmap', 'radar')
            
        Returns:
            Plotly figure object
        """
        if chart_type == "bar":
            return self._create_bar_chart(results)
        elif chart_type == "heatmap":
            return self._create_heatmap(results)
        elif chart_type == "radar":
            return self._create_radar_chart(results)
        else:
            return self._create_bar_chart(results)
    
    def _create_bar_chart(self, results: Dict) -> go.Figure:
        """Create bar chart for report"""
        import pandas as pd
        
        data = []
        for policy_name, scenarios in results.items():
            for scenario_name, scenario_data in scenarios.items():
                metrics = scenario_data['metrics']
                data.append({
                    'Policy': policy_name,
                    'Scenario': scenario_name,
                    'Delay': metrics.get('average_delay', 0),
                    'Throughput': metrics.get('throughput', 0),
                    'Emissions': metrics.get('co2_emissions', 0)
                })
        
        df = pd.DataFrame(data)
        
        fig = px.bar(df, x='Scenario', y='Delay', color='Policy',
                    title='Average Delay Comparison',
                    barmode='group')
        
        return fig
    
    def _create_heatmap(self, results: Dict) -> go.Figure:
        """Create heatmap for report"""
        import pandas as pd
        
        # Prepare data
        data = []
        for policy_name, scenarios in results.items():
            row = {'Policy': policy_name}
            for scenario_name, scenario_data in scenarios.items():
                row[scenario_name] = scenario_data['metrics'].get('average_delay', 0)
            data.append(row)
        
        df = pd.DataFrame(data)
        df = df.set_index('Policy')
        
        fig = go.Figure(data=go.Heatmap(
            z=df.values,
            x=df.columns,
            y=df.index,
            colorscale='RdYlGn_r'
        ))
        
        fig.update_layout(title='Performance Heatmap (Average Delay)')
        
        return fig
    
    def _create_radar_chart(self, results: Dict) -> go.Figure:
        """Create radar chart for report"""
        fig = go.Figure()
        
        # Take first policy as example
        if results:
            policy_name = list(results.keys())[0]
            scenarios = results[policy_name]
            
            for scenario_name, data in scenarios.items():
                metrics = data['metrics']
                
                values = [
                    metrics.get('average_delay', 0) / 3,  # Normalize
                    metrics.get('throughput', 0) / 20,
                    100 - (metrics.get('co2_emissions', 0) / 10),
                    metrics.get('average_speed', 0) * 1.5
                ]
                
                fig.add_trace(go.Scatterpolar(
                    r=values,
                    theta=['Delay', 'Throughput', 'Emissions', 'Speed'],
                    fill='toself',
                    name=scenario_name
                ))
        
        fig.update_layout(
            polar=dict(radialaxis=dict(visible=True, range=[0, 100])),
            title='Multi-Metric Performance Radar'
        )
        
        return fig